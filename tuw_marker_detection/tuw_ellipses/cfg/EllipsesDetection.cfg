#! /usr/bin/env python
#Autogenerated V4L Dynamic Control

PACKAGE='tuw_ellipses'
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()

gen.add("show_camera_image", bool_t, 0, "Show camera image", True)
gen.add("show_camera_image_waitkey", int_t, 0, "Time to draw the camera image in ms", 2, 1, 1000)
gen.add("debug", bool_t, 0, "Shows additional debug information", False)
gen.add("plubishTF", bool_t, 0, "publish tf messages", True)
gen.add("plubishMarker", bool_t, 0, "plublish marker messages", True)
gen.add("publishFiducials", bool_t, 0, "plublish marker messages", True)
gen.add("distorted_input", bool_t, 0, "the input image is distort", True)
gen.add("debug_freeze", bool_t, 0, "Freezes the input image", False)
gen.add("image_skip", int_t, 0, "skip frames", 0, 0, 100)
enum_edge_detection = gen.enum([gen.const("threshold", int_t, 0, "BW Threshold"),   
                               gen.const("canny", int_t, 1, "Canny")], 
                               "Edge detection strategy") 
gen.add("edge_detection", int_t, 0, "Edge detection strategy", 1, 0, 2, edit_method=enum_edge_detection)
gen.add("threshold_edge_detection1", int_t, 0, "edge detection", 150, 0, 255)
gen.add("threshold_edge_detection2", int_t, 0, "edge detection", 100, 0, 255)
gen.add("kernel_size_edge_detection", int_t, 0, "edge detection", 3, 3, 7)
enum_edge_linking = gen.enum([gen.const("opencv_approx_non", int_t, 0, "OpenCV"),   
                               gen.const("opencv_approx_simple", int_t, 1, "OpenCV"),
                               gen.const("v4r_simple", int_t, 2, "V4R"),   
                               gen.const("v4r_complex", int_t, 3, "V4R"),   
                               gen.const("v4r_contour", int_t, 4, "V4R")], 
                               "Edge linking strategy") 
gen.add("edge_linking", int_t, 0, "Edge detection strategy", 1, 0, 4, edit_method=enum_edge_linking)
gen.add("threshold_contour_min_points", int_t, 0, "edge detection", 20, 10, 255)
gen.add("threshold_polygon", int_t, 0, "epsylon to approximate polygon", 5, 3, 16)
gen.add("filter_convex", bool_t, 0, "rings only", True)
gen.add("threshold_rotated_rect_ratio", double_t, 0, "ring cirlce ratio", 0.02, 0, 1)
gen.add("ellipse_redefinement", bool_t, 0, "Dual ellipse redefinement", True)
gen.add("filter_contour_mean", bool_t, 0, "rings only", True)
gen.add("threshold_contour_mean", double_t, 0, "ring cirlce ratio", 0.05, 0, 0.5)
gen.add("threshold_min_radius", double_t, 0, "min radius in ration to image", 0.0, 0, 1)
gen.add("threshold_max_radius", double_t, 0, "max radius in ration to image", 1.0, 0, 1)
gen.add("filter_rings", bool_t, 0, "rings only", True)
gen.add("threshold_ring_center", double_t, 0, "ring center offsets", 0.1, 0, 0.5)
gen.add("threshold_ring_ratio", double_t, 0, "ring cirlce ratio", 0.1, 0, 1.0)
enum_estimate_pose = gen.enum([gen.const("off", int_t, 0, "Off"),     
                               gen.const("solvePnP", int_t, 1, "OpenCV"), 
                               gen.const("pose_from_ellipse", int_t, 2, "Trucco")], 
                               "Pose estimation strategy") 
gen.add("pose_estimation", int_t, 0, "Estimate Pose", 1, 0, 2, edit_method=enum_estimate_pose)
gen.add("circle_diameter", double_t, 0, "ring cirlce ratio", 0.63, 0, 1.0)
gen.add("skip_second_tf", bool_t, 0, "skips publishing the scound solution as tf", True)

exit(gen.generate(PACKAGE, "tuw_ellipses", "EllipsesDetection"))
